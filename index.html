<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pebble Street Giveaway</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;900&family=Space+Mono:wght@400;700&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: linear-gradient(135deg, #0a0e27 0%, #151932 50%, #0a0e27 100%);
            color: #ffffff;
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 20% 50%, rgba(120, 119, 198, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 80% 50%, rgba(255, 119, 198, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 50% 100%, rgba(119, 198, 255, 0.3) 0%, transparent 50%);
            pointer-events: none;
            opacity: 0.4;
        }

        .header {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(20px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding: 30px 25px;
            position: relative;
            z-index: 10;
        }

        .header-content {
            max-width: 1800px;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 20px;
        }

        .logo-container {
            width: 120px;
            height: 120px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 10px;
        }

        .logo-container img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            filter: drop-shadow(0 4px 20px rgba(0, 0, 0, 0.3));
        }

        .default-logo {
            width: 100px;
            height: 100px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 48px;
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.3);
        }

        h1 {
            font-size: 2.8em;
            font-weight: 700;
            background: linear-gradient(135deg, #667eea 0%, #f093fb 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            letter-spacing: -0.5px;
            text-align: center;
        }

        .subtitle {
            font-family: 'Space Mono', monospace;
            font-size: 1em;
            color: rgba(255, 255, 255, 0.6);
            margin-top: 5px;
            text-align: center;
        }

        .controls {
            background: rgba(255, 255, 255, 0.03);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding: 20px;
            position: relative;
            z-index: 10;
        }

        .controls-inner {
            max-width: 1800px;
            margin: 0 auto;
            display: flex;
            justify-content: center;
            gap: 25px;
            align-items: center;
            flex-wrap: wrap;
        }

        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
        }

        .file-input-wrapper input[type=file] {
            position: absolute;
            left: -9999px;
        }

        .file-input-label {
            display: inline-block;
            padding: 12px 28px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-weight: 600;
            font-size: 0.95em;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .file-input-label:hover {
            transform: translateY(-2px);
            box-shadow: 0 7px 25px rgba(102, 126, 234, 0.5);
        }

        .logo-input-label {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            box-shadow: 0 4px 15px rgba(240, 147, 251, 0.4);
        }

        .logo-input-label:hover {
            box-shadow: 0 7px 25px rgba(240, 147, 251, 0.5);
        }

        .winner-input {
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(255, 255, 255, 0.05);
            padding: 8px 16px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .winner-input label {
            font-weight: 500;
            color: rgba(255, 255, 255, 0.8);
            font-size: 0.95em;
        }

        .winner-input input {
            width: 50px;
            padding: 6px 10px;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            border-radius: 8px;
            font-weight: 600;
            text-align: center;
            transition: all 0.3s;
        }

        .winner-input input:focus {
            outline: none;
            border-color: #667eea;
            background: rgba(255, 255, 255, 0.1);
        }

        button {
            padding: 12px 32px;
            background: linear-gradient(135deg, #56ccf2 0%, #2f80ed 100%);
            color: white;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.95em;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 4px 15px rgba(47, 128, 237, 0.4);
            position: relative;
            overflow: hidden;
        }

        button::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        button:hover::before {
            width: 300px;
            height: 300px;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 7px 25px rgba(47, 128, 237, 0.5);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .main-content {
            display: flex;
            gap: 25px;
            padding: 25px;
            max-width: 1800px;
            margin: 0 auto;
            position: relative;
            z-index: 1;
        }

        .track-container {
            flex: 1;
            background: rgba(255, 255, 255, 0.03);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 25px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            position: relative;
        }

        #raceCanvas {
            width: 100%;
            height: 700px;
            border-radius: 16px;
            background: linear-gradient(135deg, #0f1419 0%, #1a1f2e 100%);
            box-shadow: inset 0 2px 20px rgba(0, 0, 0, 0.5);
        }

        .leaderboard {
            width: 380px;
            background: rgba(255, 255, 255, 0.03);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 25px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            max-height: 800px;
            overflow-y: auto;
        }

        .leaderboard::-webkit-scrollbar {
            width: 8px;
        }

        .leaderboard::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
        }

        .leaderboard::-webkit-scrollbar-thumb {
            background: rgba(102, 126, 234, 0.5);
            border-radius: 4px;
        }

        .leaderboard::-webkit-scrollbar-thumb:hover {
            background: rgba(102, 126, 234, 0.7);
        }

        .leaderboard h2 {
            font-size: 1.5em;
            margin-bottom: 20px;
            text-align: center;
            font-weight: 600;
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .driver-entry {
            display: flex;
            align-items: center;
            padding: 12px;
            margin-bottom: 8px;
            background: rgba(255, 255, 255, 0.04);
            border-radius: 12px;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .driver-entry:hover {
            background: rgba(255, 255, 255, 0.06);
            transform: translateX(4px);
        }

        .driver-entry.gold {
            background: linear-gradient(90deg, rgba(255, 215, 0, 0.15) 0%, rgba(255, 215, 0, 0.05) 100%);
            border: 1px solid rgba(255, 215, 0, 0.3);
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.2);
            animation: goldShimmer 2s infinite;
        }

        @keyframes goldShimmer {
            0%, 100% { box-shadow: 0 0 10px rgba(255, 215, 0, 0.3); }
            50% { box-shadow: 0 0 20px rgba(255, 215, 0, 0.6); }
        }

        .driver-entry.silver {
            background: linear-gradient(90deg, rgba(192, 192, 192, 0.15) 0%, rgba(192, 192, 192, 0.05) 100%);
            border: 1px solid rgba(192, 192, 192, 0.3);
        }

        .driver-entry.bronze {
            background: linear-gradient(90deg, rgba(205, 127, 50, 0.15) 0%, rgba(205, 127, 50, 0.05) 100%);
            border: 1px solid rgba(205, 127, 50, 0.3);
        }

        .position {
            font-size: 1.2em;
            font-weight: 700;
            width: 35px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-family: 'Space Mono', monospace;
        }

        .driver-name {
            flex: 1;
            padding: 0 12px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            font-weight: 500;
            color: rgba(255, 255, 255, 0.9);
        }

        .driver-status {
            display: flex;
            align-items: center;
            gap: 8px;
            font-family: 'Space Mono', monospace;
            font-size: 0.85em;
        }

        .lap-counter {
            color: #56ccf2;
            font-weight: 600;
        }

        .drs-indicator {
            color: #4ade80;
            font-weight: bold;
            animation: pulse 1s infinite;
        }

        .race-info {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            padding: 16px;
            border-radius: 12px;
            margin-bottom: 20px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .race-status {
            font-size: 1.1em;
            color: #56ccf2;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        .lap-info {
            font-family: 'Space Mono', monospace;
            color: rgba(255, 255, 255, 0.7);
            font-size: 0.95em;
            text-align: center;
        }

        .race-timer {
            font-family: 'Space Mono', monospace;
            color: #4ade80;
            font-size: 1.2em;
            font-weight: bold;
        }

        .winner-announcement {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            background: linear-gradient(135deg, rgba(15, 20, 25, 0.98) 0%, rgba(26, 31, 46, 0.98) 100%);
            backdrop-filter: blur(20px);
            padding: 50px;
            border-radius: 24px;
            box-shadow: 0 25px 60px rgba(0,0,0,0.8);
            z-index: 1000;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
            animation: winnerAppear 0.5s forwards;
            max-width: 600px;
        }

        @keyframes winnerAppear {
            to {
                transform: translate(-50%, -50%) scale(1);
            }
        }

        .winner-announcement h2 {
            font-size: 2.5em;
            margin-bottom: 30px;
            font-weight: 700;
            background: linear-gradient(135deg, #ffd700 0%, #ffed4e 50%, #ffd700 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            0%, 100% { 
                filter: brightness(1);
            }
            50% { 
                filter: brightness(1.3);
            }
        }

        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            backdrop-filter: blur(5px);
            z-index: 999;
            display: none;
        }

        .countdown {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 4em;
            font-weight: 700;
            font-family: 'Space Mono', monospace;
            text-shadow: 0 0 40px currentColor;
            animation: countdownPulse 1s ease-out;
            z-index: 100;
        }

        @keyframes countdownPulse {
            0% {
                transform: translate(-50%, -50%) scale(0);
                opacity: 0;
            }
            50% {
                transform: translate(-50%, -50%) scale(1.2);
                opacity: 1;
            }
            100% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 0.9;
            }
        }

        .track-section-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(74, 222, 128, 0.1);
            backdrop-filter: blur(10px);
            padding: 10px 20px;
            border-radius: 10px;
            font-family: 'Space Mono', monospace;
            color: #4ade80;
            border: 1px solid rgba(74, 222, 128, 0.3);
            font-weight: 600;
            font-size: 0.9em;
        }

        .winner-entry {
            font-size: 1.4em;
            margin: 20px 0;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.9);
            font-weight: 500;
        }

        .race-time {
            margin-top: 30px;
            color: #56ccf2;
            font-family: 'Space Mono', monospace;
            font-size: 1.1em;
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="header-content">
            <div class="logo-container" id="logoContainer">
                <div class="default-logo">üèÅ</div>
            </div>
            <h1>Pebble Street Giveaway</h1>
            <div class="subtitle">Upload your list and watch the race!</div>
        </div>
    </div>

    <div class="controls">
        <div class="controls-inner">
            <div class="file-input-wrapper">
                <input type="file" id="logoFile" accept="image/*">
                <label for="logoFile" class="file-input-label logo-input-label">üì∑ Upload Logo</label>
            </div>
            
            <div class="file-input-wrapper">
                <input type="file" id="csvFile" accept=".csv">
                <label for="csvFile" class="file-input-label">üìÅ Upload Participants</label>
            </div>
            
            <div class="winner-input">
                <label for="winnerCount">Top</label>
                <input type="number" id="winnerCount" min="1" value="3">
                <label>Winners</label>
            </div>
            
            <button onclick="startRace()" id="startBtn" disabled>üèéÔ∏è Start Race</button>
        </div>
    </div>

    <div class="main-content">
        <div class="track-container">
            <div class="race-info">
                <div class="race-status" id="raceStatus">Waiting for Participants...</div>
                <div class="lap-info" id="lapInfo">Pebble Street Circuit</div>
                <div class="race-timer" id="raceTimer">00:00</div>
            </div>
            <canvas id="raceCanvas"></canvas>
            <div class="track-section-indicator" id="sectionIndicator" style="display: none;">DRS ZONE ACTIVE</div>
        </div>
        
        <div class="leaderboard">
            <h2>üèÜ Leaderboard</h2>
            <div id="leaderboardContent"></div>
        </div>
    </div>

    <div class="overlay" id="overlay"></div>
    <div class="winner-announcement" id="winnerAnnouncement" style="display: none;"></div>

    <script>
        const canvas = document.getElementById('raceCanvas');
        const ctx = canvas.getContext('2d');
        let participants = [];
        let cars = [];
        let raceInProgress = false;
        let animationId = null;
        const TOTAL_LAPS = 5;
        let raceStartTime = 0;
        let frameCount = 0;

        // Logo handling
        document.getElementById('logoFile').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const img = document.createElement('img');
                    img.src = e.target.result;
                    const logoContainer = document.getElementById('logoContainer');
                    logoContainer.innerHTML = '';
                    logoContainer.appendChild(img);
                };
                reader.readAsDataURL(file);
            }
        });

        // Set canvas size
        function resizeCanvas() {
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Complex racing circuit
        class Track {
            constructor() {
                this.trackWidth = 50;
                this.setupTrackPoints();
            }

            setupTrackPoints() {
                const cx = canvas.width / 2;
                const cy = canvas.height / 2;
                const scale = Math.min(canvas.width, canvas.height) * 0.35;
                
                this.sections = [
                    { type: 'straight', speed: 1.3, drs: true, overtaking: true },
                    { type: 'corner', speed: 0.7, radius: 'tight' },
                    { type: 'corner', speed: 0.8, radius: 'medium' },
                    { type: 'straight', speed: 1.1, overtaking: true },
                    { type: 'chicane', speed: 0.6 },
                    { type: 'corner', speed: 0.9, radius: 'medium' },
                    { type: 'hairpin', speed: 0.5 },
                    { type: 'straight', speed: 1.2, drs: true, overtaking: true },
                    { type: 'corner', speed: 0.85, radius: 'fast' },
                    { type: 'chicane', speed: 0.65 },
                    { type: 'corner', speed: 0.75, radius: 'medium' },
                    { type: 'straight', speed: 1.15 },
                ];

                this.points = [];
                const numPoints = 200;
                
                for (let i = 0; i < numPoints; i++) {
                    const t = (i / numPoints) * Math.PI * 2;
                    const sectionIndex = Math.floor((i / numPoints) * this.sections.length);
                    const section = this.sections[sectionIndex];
                    
                    let x, y;
                    const baseAngle = t;
                    
                    const r1 = 1 + 0.3 * Math.sin(t * 2);
                    const r2 = 1 + 0.2 * Math.cos(t * 3);
                    const r = r1 * r2;
                    
                    x = cx + scale * r * Math.cos(baseAngle) * 1.2;
                    y = cy + scale * r * Math.sin(baseAngle) * 0.8;
                    
                    if (section.type === 'chicane') {
                        x += Math.sin(t * 20) * 20;
                        y += Math.cos(t * 20) * 15;
                    } else if (section.type === 'hairpin') {
                        const hairpinFactor = Math.sin(t * 4) * 0.3;
                        x += hairpinFactor * scale * 0.5;
                    }
                    
                    this.points.push({
                        x: x,
                        y: y,
                        section: section,
                        sectionIndex: sectionIndex
                    });
                }

                // Smooth the track
                for (let j = 0; j < 3; j++) {
                    for (let i = 1; i < this.points.length - 1; i++) {
                        this.points[i].x = (this.points[i-1].x + this.points[i].x + this.points[i+1].x) / 3;
                        this.points[i].y = (this.points[i-1].y + this.points[i].y + this.points[i+1].y) / 3;
                    }
                }
            }

            draw() {
                // Track surface gradient
                const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
                gradient.addColorStop(0, '#141824');
                gradient.addColorStop(1, '#1f2333');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Track borders - outer
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.lineWidth = this.trackWidth + 24;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.beginPath();
                for (let i = 0; i < this.points.length; i++) {
                    if (i === 0) {
                        ctx.moveTo(this.points[i].x, this.points[i].y);
                    } else {
                        ctx.lineTo(this.points[i].x, this.points[i].y);
                    }
                }
                ctx.closePath();
                ctx.stroke();

                // Track surface
                ctx.strokeStyle = '#2a2f3f';
                ctx.lineWidth = this.trackWidth;
                ctx.stroke();

                // Track center line
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
                ctx.lineWidth = 2;
                ctx.setLineDash([15, 15]);
                ctx.stroke();
                ctx.setLineDash([]);

                // Kerbs on corners - modern style
                for (let i = 0; i < this.points.length; i++) {
                    if (this.points[i].section.type === 'corner' || this.points[i].section.type === 'chicane') {
                        const p = this.points[i];
                        const kerbColor = (Math.floor(i / 5) % 2 === 0) 
                            ? 'rgba(102, 126, 234, 0.6)' 
                            : 'rgba(240, 147, 251, 0.6)';
                        ctx.fillStyle = kerbColor;
                        ctx.fillRect(p.x - 3, p.y - 3, 6, 6);
                    }
                }

                // DRS zones with modern styling
                for (let i = 0; i < this.points.length; i++) {
                    if (this.points[i].section.drs) {
                        const p = this.points[i];
                        ctx.strokeStyle = '#4ade80';
                        ctx.lineWidth = 2;
                        ctx.globalAlpha = 0.2;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, this.trackWidth/2, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.globalAlpha = 1;
                    }
                }

                // Start/Finish line
                const startPoint = this.points[0];
                const nextPoint = this.points[1];
                const angle = Math.atan2(nextPoint.y - startPoint.y, nextPoint.x - startPoint.x) + Math.PI/2;
                
                // Modern checkered pattern
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(startPoint.x + Math.cos(angle) * this.trackWidth/2, 
                          startPoint.y + Math.sin(angle) * this.trackWidth/2);
                ctx.lineTo(startPoint.x - Math.cos(angle) * this.trackWidth/2, 
                          startPoint.y - Math.sin(angle) * this.trackWidth/2);
                ctx.stroke();

                // Subtle checkered pattern
                for (let i = -3; i <= 3; i++) {
                    for (let j = -2; j <= 2; j++) {
                        ctx.fillStyle = (i + j) % 2 === 0 
                            ? 'rgba(255, 255, 255, 0.7)' 
                            : 'rgba(0, 0, 0, 0.7)';
                        ctx.fillRect(startPoint.x + i * 6 - 18, startPoint.y + j * 6 - 12, 6, 6);
                    }
                }
            }

            getPosition(progress, laneOffset) {
                const index = Math.floor(progress * this.points.length) % this.points.length;
                const nextIndex = (index + 1) % this.points.length;
                const t = (progress * this.points.length) % 1;
                
                const point = this.points[index];
                const nextPoint = this.points[nextIndex];
                
                const x = point.x + (nextPoint.x - point.x) * t;
                const y = point.y + (nextPoint.y - point.y) * t;
                
                const angle = Math.atan2(nextPoint.y - point.y, nextPoint.x - point.x);
                
                const offsetX = x + Math.cos(angle + Math.PI/2) * laneOffset;
                const offsetY = y + Math.sin(angle + Math.PI/2) * laneOffset;
                
                return { 
                    x: offsetX, 
                    y: offsetY, 
                    angle: angle,
                    section: point.section
                };
            }
        }

        class Car {
            constructor(name, color, index) {
                this.name = name;
                this.color = color;
                this.index = index;
                this.progress = index * 0.001;
                this.laps = 0;
                this.baseSpeed = 0.0015 + Math.random() * 0.0005;
                this.currentSpeed = this.baseSpeed;
                this.targetLane = 0;
                this.currentLane = 0;
                this.finished = false;
                this.finishPosition = null;
                this.sparkles = [];
                this.slipstream = false;
                this.drsActive = false;
                this.tireWear = 0;
                this.overtakeAttempt = false;
                this.skill = 0.7 + Math.random() * 0.3;
                this.aggressiveness = 0.3 + Math.random() * 0.7;
                this.lastOvertakeAttempt = 0;
                this.momentum = 1.0;
                this.mistakes = 0;
                this.lastMistake = 0;
                this.recoveryMode = false;
                this.luckyStreak = 0;
            }

            update() {
                if (this.finished) return;

                const pos = track.getPosition(this.progress, this.currentLane * 8);
                
                this.tireWear += 0.00001 * (0.8 + Math.random() * 0.4);
                const tireEffect = 1 - (this.tireWear * 0.4);
                
                const sectionSpeed = pos.section.speed || 1;
                
                this.checkSlipstream();
                const slipstreamBoost = this.slipstream ? 1.15 : 1;
                
                if (pos.section.drs && this.hasCarAhead(0.01)) {
                    this.drsActive = true;
                    document.getElementById('sectionIndicator').style.display = 'block';
                } else {
                    this.drsActive = false;
                }
                const drsBoost = this.drsActive ? 1.2 : 1;
                
                // CHAOS MECHANICS
                
                if (Math.random() < 0.1) {
                    this.momentum *= (0.85 + Math.random() * 0.3);
                    this.momentum = Math.max(0.7, Math.min(1.3, this.momentum));
                }
                
                if (Math.random() < 0.02 && Date.now() - this.lastMistake > 2000) {
                    this.currentSpeed *= 0.3;
                    this.createSparks(true);
                    this.mistakes++;
                    this.lastMistake = Date.now();
                    this.recoveryMode = true;
                    this.targetLane = Math.random() < 0.5 ? -1 : 1;
                    
                    setTimeout(() => {
                        this.recoveryMode = false;
                        this.targetLane = 0;
                    }, 1500);
                }
                
                if (Math.random() < 0.05) {
                    this.luckyStreak = Math.min(this.luckyStreak + 1, 10);
                } else if (Math.random() < 0.03) {
                    this.luckyStreak = Math.max(this.luckyStreak - 1, 0);
                }
                const luckBoost = 1 + (this.luckyStreak * 0.02);
                
                const lastLapBoost = this.laps >= TOTAL_LAPS - 1 ? 1.15 + Math.random() * 0.15 : 1;
                
                const sorted = [...cars].sort((a, b) => b.totalProgress - a.totalProgress);
                const myPosition = sorted.indexOf(this) + 1;
                const comebackBoost = myPosition > 5 ? 1 + (myPosition * 0.01) : 1;
                
                let mechanicalPenalty = 1;
                if (Math.random() < 0.01) {
                    mechanicalPenalty = 0.7;
                    this.createSparks(true);
                }
                
                this.currentSpeed = this.baseSpeed * 
                    sectionSpeed * 
                    tireEffect * 
                    slipstreamBoost * 
                    drsBoost * 
                    this.skill * 
                    this.momentum * 
                    luckBoost *
                    lastLapBoost *
                    comebackBoost *
                    mechanicalPenalty;
                
                if (Math.random() < 0.15) {
                    this.currentSpeed *= (0.8 + Math.random() * 0.4);
                }
                
                if (pos.section.overtaking && Math.random() < 0.05) {
                    this.attemptOvertake();
                }
                
                if (this.currentLane !== this.targetLane) {
                    const laneChangeSpeed = 0.3;
                    if (Math.abs(this.currentLane - this.targetLane) < laneChangeSpeed) {
                        this.currentLane = this.targetLane;
                    } else {
                        this.currentLane += (this.targetLane - this.currentLane) * laneChangeSpeed;
                    }
                }
                
                if ((pos.section.type === 'chicane' || pos.section.type === 'hairpin') && Math.random() < 0.04) {
                    this.currentSpeed *= 0.4;
                    this.createSparks(true);
                }
                
                this.progress += this.currentSpeed;
                
                if (this.progress >= 1) {
                    this.progress -= 1;
                    this.laps++;
                    
                    if (Math.random() < 0.1 && this.laps < TOTAL_LAPS) {
                        this.currentSpeed *= 0.5;
                        this.createSparks();
                        setTimeout(() => {
                            this.tireWear = 0;
                            this.momentum = 1.2;
                        }, 1000);
                    }
                    
                    if (this.laps >= TOTAL_LAPS) {
                        this.finished = true;
                        this.finishPosition = cars.filter(c => c.finished).length + 1;
                    }
                }
                
                this.sparkles = this.sparkles.filter(s => s.life > 0);
                this.sparkles.forEach(s => {
                    s.x += s.vx;
                    s.y += s.vy;
                    s.life--;
                });
            }

            checkSlipstream() {
                this.slipstream = false;
                const myPos = this.progress + this.laps;
                
                for (let car of cars) {
                    if (car === this) continue;
                    const otherPos = car.progress + car.laps;
                    const distance = otherPos - myPos;
                    
                    if (distance > 0 && distance < 0.005 && Math.abs(car.currentLane - this.currentLane) < 1) {
                        this.slipstream = true;
                        if (Math.random() < 0.01) this.createSparks();
                        break;
                    }
                }
            }

            hasCarAhead(distance) {
                const myPos = this.progress + this.laps;
                return cars.some(car => {
                    if (car === this) return false;
                    const otherPos = car.progress + car.laps;
                    return otherPos - myPos > 0 && otherPos - myPos < distance;
                });
            }

            attemptOvertake() {
                if (Date.now() - this.lastOvertakeAttempt < 1500) return;
                
                const myPos = this.progress + this.laps;
                let targetLane = null;
                
                for (let car of cars) {
                    if (car === this) continue;
                    const otherPos = car.progress + car.laps;
                    const distance = otherPos - myPos;
                    
                    if (distance > 0 && distance < 0.015) {
                        if (car.currentLane === 0) {
                            targetLane = Math.random() < 0.5 ? -1 : 1;
                        } else {
                            targetLane = 0;
                        }
                        
                        if (Math.random() < 0.3) {
                            targetLane = Math.random() < 0.5 ? -2 : 2;
                        }
                        break;
                    }
                }
                
                if (targetLane !== null && Math.abs(targetLane) <= 2) {
                    this.targetLane = targetLane;
                    this.overtakeAttempt = true;
                    this.lastOvertakeAttempt = Date.now();
                    this.createSparks();
                    
                    this.momentum *= 1.1;
                    
                    setTimeout(() => {
                        this.targetLane = 0;
                        this.overtakeAttempt = false;
                    }, 1500);
                }
            }

            createSparks(mistake = false) {
                const pos = track.getPosition(this.progress, this.currentLane * 8);
                const count = mistake ? 10 : 5;
                const color = mistake ? '255, 100, 100' : '86, 204, 242';
                
                for (let i = 0; i < count; i++) {
                    this.sparkles.push({
                        x: pos.x,
                        y: pos.y,
                        vx: (Math.random() - 0.5) * 4,
                        vy: (Math.random() - 0.5) * 4,
                        life: 20,
                        color: color
                    });
                }
            }

            draw() {
                const pos = track.getPosition(this.progress, this.currentLane * 8);
                
                this.sparkles.forEach(s => {
                    ctx.fillStyle = `rgba(${s.color}, ${s.life / 20})`;
                    ctx.fillRect(s.x - 1, s.y - 1, 3, 3);
                });
                
                if (this.slipstream) {
                    const gradient = ctx.createRadialGradient(pos.x, pos.y, 0, pos.x, pos.y, 20);
                    gradient.addColorStop(0, 'rgba(86, 204, 242, 0.3)');
                    gradient.addColorStop(1, 'rgba(86, 204, 242, 0)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(pos.x - 20, pos.y - 20, 40, 40);
                }
                
                if (this.drsActive) {
                    ctx.fillStyle = 'rgba(74, 222, 128, 0.6)';
                    ctx.fillRect(pos.x - 12, pos.y - 18, 24, 4);
                }
                
                const sorted = [...cars].sort((a, b) => b.totalProgress - a.totalProgress);
                const myPosition = sorted.indexOf(this) + 1;
                
                if (myPosition <= 3 && !this.finished) {
                    ctx.save();
                    
                    const glowColor = myPosition === 1 ? 'rgba(255, 215, 0, 0.6)' : 
                                     myPosition === 2 ? 'rgba(192, 192, 192, 0.6)' : 
                                     'rgba(205, 127, 50, 0.6)';
                    
                    const pulseScale = 1 + Math.sin(Date.now() * 0.005) * 0.1;
                    
                    ctx.shadowColor = glowColor;
                    ctx.shadowBlur = 20;
                    
                    ctx.translate(pos.x, pos.y - 40);
                    ctx.scale(pulseScale, pulseScale);
                    
                    ctx.font = 'bold 24px Space Mono';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    if (myPosition === 1) {
                        ctx.fillStyle = '#ffd700';
                        ctx.fillText('üëë', 0, 0);
                        
                        ctx.font = 'bold 12px Inter';
                        ctx.fillStyle = '#ffd700';
                        ctx.shadowBlur = 10;
                        ctx.fillText('1ST', 0, 18);
                    } else if (myPosition === 2) {
                        ctx.fillStyle = '#c0c0c0';
                        ctx.fillText('ü•à', 0, 0);
                        
                        ctx.font = 'bold 12px Inter';
                        ctx.fillStyle = '#c0c0c0';
                        ctx.shadowBlur = 10;
                        ctx.fillText('2ND', 0, 18);
                    } else if (myPosition === 3) {
                        ctx.fillStyle = '#cd7f32';
                        ctx.fillText('ü•â', 0, 0);
                        
                        ctx.font = 'bold 12px Inter';
                        ctx.fillStyle = '#cd7f32';
                        ctx.shadowBlur = 10;
                        ctx.fillText('3RD', 0, 18);
                    }
                    
                    ctx.restore();
                    
                    if (myPosition === 1) {
                        ctx.strokeStyle = 'rgba(255, 215, 0, 0.3)';
                        ctx.lineWidth = 3;
                        ctx.lineCap = 'round';
                        ctx.globalAlpha = 0.6;
                        ctx.beginPath();
                        ctx.moveTo(pos.x, pos.y);
                        
                        for (let i = 1; i <= 5; i++) {
                            const trailProgress = this.progress - (i * 0.003);
                            const trailPos = track.getPosition(trailProgress < 0 ? 1 + trailProgress : trailProgress, this.currentLane * 8);
                            ctx.lineTo(trailPos.x, trailPos.y);
                        }
                        ctx.stroke();
                        ctx.globalAlpha = 1;
                    }
                }
                
                ctx.save();
                ctx.translate(pos.x, pos.y);
                ctx.rotate(pos.angle + Math.PI / 2);
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fillRect(-7, -10, 14, 20);
                
                const carGradient = ctx.createLinearGradient(-8, 0, 8, 0);
                carGradient.addColorStop(0, this.color);
                carGradient.addColorStop(0.5, this.adjustBrightness(this.color, 20));
                carGradient.addColorStop(1, this.color);
                ctx.fillStyle = carGradient;
                ctx.fillRect(-8, -12, 16, 24);
                
                if (myPosition <= 3 && !this.finished) {
                    ctx.strokeStyle = myPosition === 1 ? '#ffd700' : 
                                     myPosition === 2 ? '#c0c0c0' : '#cd7f32';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(-8, -12, 16, 24);
                }
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(-5, -7, 10, 6);
                ctx.fillRect(-7, 7, 14, 3);
                ctx.fillRect(-7, -10, 14, 2);
                
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 8px Space Mono';
                ctx.textAlign = 'center';
                ctx.fillText(this.index + 1, 0, 3);
                
                ctx.restore();
                
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.font = '600 9px Inter';
                ctx.textAlign = 'center';
                ctx.shadowColor = 'rgba(0,0,0,0.8)';
                ctx.shadowBlur = 4;
                ctx.fillText(this.name.substring(0, 12), pos.x, pos.y - 22);
                ctx.shadowBlur = 0;
            }

            adjustBrightness(color, percent) {
                const num = parseInt(color.replace("#",""), 16);
                const amt = Math.round(2.55 * percent);
                const R = (num >> 16) + amt;
                const G = (num >> 8 & 0x00FF) + amt;
                const B = (num & 0x0000FF) + amt;
                return "#" + (0x1000000 + (R<255?R<1?0:R:255)*0x10000 + 
                    (G<255?G<1?0:G:255)*0x100 + (B<255?B<1?0:B:255))
                    .toString(16).slice(1);
            }

            get totalProgress() {
                return this.laps + this.progress;
            }
        }

        const track = new Track();

        document.getElementById('csvFile').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const text = e.target.result;
                    parseCSV(text);
                };
                reader.readAsText(file);
            }
        });

        function parseCSV(text) {
            const lines = text.split('\n').filter(line => line.trim());
            participants = [];
            
            const startIndex = lines[0].toLowerCase().includes('name') ? 1 : 0;
            
            for (let i = startIndex; i < lines.length; i++) {
                const name = lines[i].trim().replace(/[",]/g, '');
                if (name) {
                    participants.push(name);
                }
            }
            
            if (participants.length > 0) {
                document.getElementById('startBtn').disabled = false;
                document.getElementById('raceStatus').textContent = `${participants.length} Drivers Ready`;
                initializeCars();
                updateLeaderboard();
            }
        }

        function initializeCars() {
            cars = [];
            const colors = [
                '#667eea', '#f093fb', '#56ccf2', '#4ade80', '#fbbf24',
                '#f87171', '#a78bfa', '#34d399', '#60a5fa', '#f472b6',
                '#fde047', '#c084fc', '#5eead4', '#fb923c', '#94a3b8',
                '#e879f9', '#86efac', '#7dd3fc', '#fca5a5', '#bfdbfe'
            ];
            
            participants.forEach((name, index) => {
                const color = colors[index % colors.length];
                cars.push(new Car(name, color, index));
            });
        }

        function updateLeaderboard() {
            const sorted = [...cars].sort((a, b) => {
                if (a.finished && b.finished) return a.finishPosition - b.finishPosition;
                if (a.finished) return -1;
                if (b.finished) return 1;
                return b.totalProgress - a.totalProgress;
            });
            const winnerCount = parseInt(document.getElementById('winnerCount').value);
            
            let html = '';
            sorted.forEach((car, index) => {
                const position = index + 1;
                let className = 'driver-entry';
                
                if (car.finished) {
                    if (position === 1) className += ' gold';
                    else if (position === 2) className += ' silver';
                    else if (position === 3) className += ' bronze';
                }
                
                const isWinner = position <= winnerCount && car.finished;
                const trophy = isWinner ? 'üèÜ' : '';
                const statusIcons = [];
                if (car.drsActive) statusIcons.push('<span class="drs-indicator">DRS</span>');
                if (car.slipstream) statusIcons.push('üí®');
                if (car.overtakeAttempt) statusIcons.push('‚ö°');
                
                html += `
                    <div class="${className}">
                        <div class="position">${position}</div>
                        <div class="driver-name">${trophy} ${car.name}</div>
                        <div class="driver-status">
                            <span class="lap-counter">L${Math.min(car.laps + 1, TOTAL_LAPS)}/${TOTAL_LAPS}</span>
                            ${statusIcons.join(' ')}
                        </div>
                    </div>
                `;
            });
            
            document.getElementById('leaderboardContent').innerHTML = html;
        }

        function updateRaceTimer() {
            if (!raceInProgress) return;
            const elapsed = Date.now() - raceStartTime;
            const minutes = Math.floor(elapsed / 60000);
            const seconds = Math.floor((elapsed % 60000) / 1000);
            document.getElementById('raceTimer').textContent = 
                `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        function showCountdown() {
            return new Promise(resolve => {
                const lights = ['üî¥', 'üî¥üî¥', 'üî¥üî¥üî¥', 'üî¥üî¥üî¥üî¥', 'üî¥üî¥üî¥üî¥üî¥', 'üü¢üü¢üü¢üü¢üü¢'];
                const track = document.querySelector('.track-container');
                let lightIndex = 0;
                
                function showLight() {
                    if (lightIndex < lights.length) {
                        const prev = track.querySelector('.countdown');
                        if (prev) prev.remove();
                        
                        const div = document.createElement('div');
                        div.className = 'countdown';
                        div.innerHTML = lights[lightIndex];
                        if (lightIndex === lights.length - 1) {
                            div.style.color = '#4ade80';
                            div.style.textShadow = '0 0 60px #4ade80';
                        } else {
                            div.style.color = '#f87171';
                            div.style.textShadow = '0 0 40px #f87171';
                        }
                        track.appendChild(div);
                        
                        lightIndex++;
                        
                        if (lightIndex === lights.length) {
                            setTimeout(() => {
                                div.remove();
                                resolve();
                            }, 500);
                        } else {
                            setTimeout(showLight, 800);
                        }
                    }
                }
                
                showLight();
            });
        }

        async function startRace() {
            if (raceInProgress || participants.length === 0) return;
            
            raceInProgress = true;
            raceStartTime = Date.now();
            document.getElementById('startBtn').disabled = true;
            document.getElementById('raceStatus').textContent = 'Grid Formation...';
            
            initializeCars();
            
            await showCountdown();
            
            document.getElementById('raceStatus').textContent = 'Race On!';
            document.getElementById('sectionIndicator').style.display = 'none';
            animate();
        }

        function animate() {
            if (!raceInProgress) return;
            
            frameCount++;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            track.draw();
            
            const sortedForDrawing = [...cars].sort((a, b) => a.totalProgress - b.totalProgress);
            
            sortedForDrawing.forEach(car => {
                car.update();
                car.draw();
            });
            
            if (frameCount % 10 === 0) {
                updateLeaderboard();
                updateRaceTimer();
                
                const leadCar = [...cars].sort((a, b) => b.totalProgress - a.totalProgress)[0];
                const gap = cars.length > 1 ? 
                    ((leadCar.totalProgress - cars[1].totalProgress) * 100).toFixed(1) : 0;
                document.getElementById('lapInfo').textContent = 
                    `Leader: ${leadCar.name} | Gap: ${gap}s`;
            }
            
            const finishedCars = cars.filter(car => car.finished);
            if (finishedCars.length === cars.length) {
                endRace();
                return;
            }
            
            animationId = requestAnimationFrame(animate);
        }

        function endRace() {
            raceInProgress = false;
            document.getElementById('raceStatus').textContent = 'Race Complete!';
            document.getElementById('startBtn').disabled = false;
            document.getElementById('sectionIndicator').style.display = 'none';
            
            const winnerCount = parseInt(document.getElementById('winnerCount').value);
            const winners = [...cars]
                .sort((a, b) => a.finishPosition - b.finishPosition)
                .slice(0, winnerCount);
            
            const totalTime = ((Date.now() - raceStartTime) / 1000).toFixed(1);
            
            let winnerHtml = '<h2>üèÜ Winners üèÜ</h2>';
            winners.forEach((car, index) => {
                const medal = index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : 'ü•â';
                winnerHtml += `<div class="winner-entry">
                    ${medal} ${car.name}
                </div>`;
            });
            winnerHtml += `<div class="race-time">
                Race Time: ${totalTime} seconds
            </div>`;
            
            document.getElementById('overlay').style.display = 'block';
            document.getElementById('winnerAnnouncement').innerHTML = winnerHtml;
            document.getElementById('winnerAnnouncement').style.display = 'block';
            
            setTimeout(() => {
                document.getElementById('overlay').style.display = 'none';
                document.getElementById('winnerAnnouncement').style.display = 'none';
            }, 7000);
        }

        track.draw();
    </script>
</body>
</html>
